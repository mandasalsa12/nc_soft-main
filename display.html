<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Display - Nurse Call Response System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { background: #f3f4f6; }
        .logo-spam { cursor: pointer; user-select: none; }

        /* Active Alert Popup Styles */
        #notification-popup-container {
            position: fixed;
            z-index: 9999;
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
        }

        .notification-popup {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-left: 4px solid #ef4444;
            opacity: 0;
            transform: translateX(100%);
            animation: alert-pulse 2s infinite;
        }

        .notification-popup.completed {
            border-left: 4px solid #22c55e !important;
            background-color: #dcfce7;
            animation: none !important; /* No blinking for completed popups */
        }

        /* Animation styles */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(100%);
            }
        }

        @keyframes alert-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        @keyframes completed-glow {
            0% { box-shadow: 0 0 5px rgba(34, 197, 94, 0.3); }
            100% { box-shadow: 0 0 5px rgba(34, 197, 94, 0.3); }
        }

        .notification-popup.show {
            animation: slideIn 0.5s forwards ease-out, alert-pulse 2s infinite;
            background-color: #fee2e2;
        }

        .notification-popup.completed {
            opacity: 1;
            transform: translateX(0);
            box-shadow: 0 0 5px rgba(34, 197, 94, 0.3); /* Static subtle shadow */
        }

        .notification-popup.hide {
            animation: slideOut 0.5s forwards ease-out;
        }
        
        /* CSS konsisten dengan display_config.html untuk koordinat yang tepat */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Custom styles untuk maximize space usage */
        .container {
            max-width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
        }
        
        /* Override Tailwind container constraints */
        .w-full {
            width: 100% !important;
            max-width: none !important;
        }
        
        /* Minimize margins and paddings */
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }
        
        #floorplan-container {
            border-width: 1px;
            margin: 0 auto;
            display: block;
            width: 100%;
            height: calc(100vh - 120px) !important;
            position: relative;
            overflow: hidden;
        }
        
        /* Center layout optimizations */
        .max-w-6xl {
            max-width: 100%;
            height: 100%;
        }
        
        /* Floorplan wrapper styling */
        .floorplan-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: calc(100vh - 120px);
            padding: 0 16px;
        }
        
        /* Image and canvas responsive styling */
        #floorplan-img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #f3f4f6;
        }

        #shape-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Header area responsive */
        .header-area {
            padding: 8px 16px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Responsive adjustments */
        @media (max-width: 1279px) {
            .header-area {
                height: 60px;
            }
            
            #floorplan-container {
                height: calc(100vh - 100px) !important;
            }
            
            .floorplan-wrapper {
                height: calc(100vh - 100px);
            }
        }
        
        @media (max-width: 768px) {
            .header-area {
                height: 50px;
            }
            
            #floorplan-container {
                height: calc(100vh - 90px) !important;
        }
        
        .floorplan-wrapper {
                height: calc(100vh - 90px);
                padding: 0 8px;
            }
        }

        /* Update animation styles */
        @keyframes alert-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .alert-pulse {
            animation: alert-pulse 1s infinite;
        }

        @keyframes slide-right {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slide-left {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fade {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .animate-slide-right { animation: slide-right var(--animation-speed, 500ms) ease-out; }
        .animate-slide-left { animation: slide-left var(--animation-speed, 500ms) ease-out; }
        .animate-fade { animation: fade var(--animation-speed, 500ms) ease-out; }

        .hide {
            opacity: 0;
            transition: opacity var(--animation-speed, 500ms) ease-out;
        }

        #notification-popup-container {
            position: fixed;
            z-index: 9999;
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <!-- Notification Popup Container -->
    <div id="notification-popup-container"></div>

    <!-- Audio Elements -->
    <audio id="notification-sound" src="sounds/ding.wav" preload="auto"></audio>
    <div id="sound-container"></div>

    <!-- Status Indicators - Fixed di kanan atas -->
    <div class="fixed top-4 right-4 flex items-center space-x-3 z-40">
        <div id="standby-indicator-card" class="bg-white p-2 rounded-lg shadow flex items-center">
            <span id="standby-indicator" class="inline-block w-2.5 h-2.5 rounded-full bg-red-500 mr-2"></span>
            <span class="font-mono text-xs">Standby</span>
        </div>
        <div class="bg-white p-2 rounded-lg shadow flex items-center">
            <i class="fas fa-clock text-blue-500 mr-2 text-xs"></i>
            <span id="current-time" class="font-mono text-xs">00:00:00</span>
        </div>
        <div class="bg-white p-2 rounded-lg shadow flex items-center">
            <i class="fas fa-calendar-day text-blue-500 mr-2 text-xs"></i>
            <span id="current-date" class="font-mono text-xs">01/01/2023</span>
        </div>
    </div>

    <!-- Container dengan padding yang minimal -->
    <div class="w-full px-1 py-2">
        <div class="flex justify-center items-center mb-4 px-1">
            <div class="text-center">
                <h1 id="logo-nurse-call" class="text-3xl font-bold text-blue-800 logo-spam select-none">
                    Nurse Call Response System
                </h1>
                <p class="text-gray-600">Display Only</p>
            </div>
                </div>
        
        <!-- Centered Floorplan Area -->
        <div class="floorplan-wrapper w-full px-1">
            <div class="w-full max-w-6xl">
                <div id="floorplan-container" class="relative border rounded-lg overflow-hidden bg-white shadow" style="min-height:calc(100vh - 280px);">
                    <img id="floorplan-img" src="" class="w-full h-full object-contain" style="background:#f3f4f6;" />
                    <canvas id="shape-canvas" class="absolute top-0 left-0"></canvas>
                </div>
            </div>
        </div>
    </div>
    <script>
        const { ipcRenderer } = require('electron');

        // Variables
        let shapes = [];
        let floorplanImg = '';
        let blinkingShapes = new Map();
        let animationFrameId = null;
        let lastCanvasSize = { width: 0, height: 0 };
        let resizeTimeout;

        // ADDED: Global timeout/interval tracking for proper cleanup
        let activeTimeouts = new Set();
        let activeIntervals = new Set();
        
        // Wrapper functions to track timeouts and intervals
        function safeSetTimeout(callback, delay) {
            const timeoutId = setTimeout(() => {
                activeTimeouts.delete(timeoutId);
                callback();
            }, delay);
            activeTimeouts.add(timeoutId);
            return timeoutId;
        }
        
        function safeClearTimeout(timeoutId) {
            clearTimeout(timeoutId);
            activeTimeouts.delete(timeoutId);
        }
        
        function safeSetInterval(callback, delay) {
            const intervalId = setInterval(callback, delay);
            activeIntervals.add(intervalId);
            return intervalId;
        }
        
        function safeClearInterval(intervalId) {
            clearInterval(intervalId);
            activeIntervals.delete(intervalId);
        }
        
        // Global cleanup function
        function performGlobalCleanup() {
            console.log('Performing global cleanup...');
            
            // Clear all active timeouts
            activeTimeouts.forEach(timeoutId => {
                clearTimeout(timeoutId);
            });
            activeTimeouts.clear();
            
            // Clear all active intervals
            activeIntervals.forEach(intervalId => {
                clearInterval(intervalId);
            });
            activeIntervals.clear();
            
            // Cleanup audio element
            cleanupGlobalAudioElement();
            
            // Clear persistent data
            if (typeof persistentSounds !== 'undefined') {
                persistentSounds.clear();
            }
            if (typeof persistentBlinking !== 'undefined') {
                persistentBlinking.clear();
            }
            
            // Clear animation frame
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Cleanup resize observer
            if (resizeObserver) {
                resizeObserver.disconnect();
                resizeObserver = null;
            }
            
            // Clear semua blinking tracking
            blinkingShapes.clear();
            
            // Reset semua shapes blinking state
            shapes.forEach(shape => {
                shape.blinking = false;
            });
            
            console.log('Global cleanup completed');
        }

        // Load display config
        async function loadDisplayConfig() {
            try {
                console.log('ðŸ—ï¸ [DISPLAY] Loading display config...');
                const config = await ipcRenderer.invoke('get-display-config');
                if (config) {
                    shapes = config.shapes || [];
                    floorplanImg = config.floorplanImg || '';
                    
                    console.log('ðŸ—ï¸ [DISPLAY] Raw config loaded - shapes count:', shapes.length);
                    
                    // Pastikan shapes memiliki properti yang diperlukan
                    shapes.forEach((shape, index) => {
                        if (!shape.color) {
                            shape.color = getShapeColor(shape.type || 'NC');
                        }
                        if (!shape.type) {
                            shape.type = 'NC';
                        }
                        if (!shape.width) {
                            shape.width = 90;
                        }
                        if (!shape.height) {
                            shape.height = 70;
                        }
                        shape.blinking = false; // Reset blinking state saat load
                        
                        console.log(`ðŸ“ [DISPLAY] Shape ${index + 1}: CODE="${shape.code}" TYPE="${shape.type}" at (${shape.x}, ${shape.y}) size ${shape.width}x${shape.height} color="${shape.color}"`);
                    });
                    
                    console.log('ðŸ—ï¸ [DISPLAY] Display config loaded:', shapes.length, 'shapes');
                    
                    // Log semua kode shape yang tersedia untuk memudahkan debugging
                    const shapeCodes = shapes.map(s => s.code).filter(code => code && code.trim() !== '');
                    console.log('ðŸ” [DISPLAY] Available shape codes for blinking:', shapeCodes);
                    
                    // Render floor plan dan shapes
                    renderFloorplan();
                    
                    return true;
                } else {
                    console.warn('âš ï¸ [DISPLAY] No display config found');
                    return false;
                }
            } catch (error) {
                console.error('âŒ [DISPLAY] Error loading display config:', error);
                return false;
            }
        }

        // Fungsi untuk mendapatkan warna shape berdasarkan tipe
        function getShapeColor(type) {
            switch(type) {
                case 'NC': return '#22c55e'; // Hijau
                case 'KM': return '#ef4444'; // Merah
                case 'CB': return '#3b82f6'; // Biru
                default: return '#6b7280';   // Abu-abu
            }
        }

        // Render floor plan - SINKRONISASI DENGAN display_config.html
        function renderFloorplan() {
            const img = document.getElementById('floorplan-img');
            if (floorplanImg) {
                img.src = floorplanImg;
                img.style.display = 'block';
                img.onload = () => {
                    console.log('Floorplan image loaded, setting up canvas...');
                    // Reset lastCanvasSize saat gambar baru dimuat (sama seperti display_config.html)
                    lastCanvasSize = { width: 0, height: 0 };
                    
                    // Pastikan canvas resize setelah gambar dimuat (delay sama)
                    setTimeout(() => {
                        updateCanvasSize();
                        // Setup ulang resize observer untuk gambar baru
                        if (resizeObserver) {
                            resizeObserver.disconnect();
                            resizeObserver = null;
                        }
                        setupResizeObserver();
                        console.log('Canvas setup completed for display.html');
                    }, 100); // Delay sama dengan display_config.html
                };
                
                // Jika gambar sudah cached, trigger onload
                if (img.complete) {
                    img.onload();
                }
            } else {
                // Tidak ada floorplan, setup default canvas (sama seperti display_config.html)
                img.src = '';
                img.style.display = 'none';
                renderShapes();
            }
        }
        
        // Update canvas size - OPTIMIZED untuk centered layout
        function updateCanvasSize() {
            const img = document.getElementById('floorplan-img');
            const canvas = document.getElementById('shape-canvas');
            const container = document.getElementById('floorplan-container');
            
            if (!img || !canvas || !container) return;
            
            const imgRect = img.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            
            const imgOffsetX = imgRect.left - containerRect.left;
            const imgOffsetY = imgRect.top - containerRect.top;
            
            const newWidth = imgRect.width || img.offsetWidth || 800;
            const newHeight = imgRect.height || img.offsetHeight || 600;
            
            console.log('Canvas size update:', { newWidth, newHeight, offsets: { x: imgOffsetX, y: imgOffsetY } });
            
            // Update canvas size dan position
            canvas.width = newWidth;
            canvas.height = newHeight;
            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';
            canvas.style.position = 'absolute';
            canvas.style.top = imgOffsetY + 'px';
            canvas.style.left = imgOffsetX + 'px';
            canvas.style.pointerEvents = 'auto';
            
            // Simpan ukuran untuk tracking
            lastCanvasSize = { width: newWidth, height: newHeight };
            
            // Render ulang shapes
            renderShapes();
        }

        // Render shapes - OPTIMIZED untuk centered layout
        function renderShapes() {
            const img = document.getElementById('floorplan-img');
            const canvas = document.getElementById('shape-canvas');
            const container = document.getElementById('floorplan-container');
            
            if (!img || !canvas || !container) return;
            
            // Pastikan canvas mengikuti ukuran gambar
            const imgRect = img.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            
            // Hitung posisi relatif gambar terhadap container
            const imgOffsetX = imgRect.left - containerRect.left;
            const imgOffsetY = imgRect.top - containerRect.top;
            
            const actualWidth = imgRect.width || img.offsetWidth || 800;
            const actualHeight = imgRect.height || img.offsetHeight || 600;
            
            // Set canvas size dan position untuk match dengan gambar
            canvas.width = actualWidth;
            canvas.height = actualHeight;
            canvas.style.width = actualWidth + 'px';
            canvas.style.height = actualHeight + 'px';
            canvas.style.position = 'absolute';
            canvas.style.top = imgOffsetY + 'px';
            canvas.style.left = imgOffsetX + 'px';
            canvas.style.pointerEvents = 'none'; // Display only, no interaction
            
            console.log('Canvas rendering:', { 
                canvasSize: { width: actualWidth, height: actualHeight },
                offset: { x: imgOffsetX, y: imgOffsetY },
                shapesCount: shapes.length 
            });
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            shapes.forEach((shape, index) => {
                ctx.save();
                
                // Pastikan shape memiliki ukuran default
                if (!shape.width) shape.width = 90;
                if (!shape.height) shape.height = 70;
                
                // Pastikan posisi shape tidak keluar dari canvas
                const maxX = canvas.width - shape.width / 2;
                const maxY = canvas.height - shape.height / 2;
                const minX = shape.width / 2;
                const minY = shape.height / 2;
                
                shape.x = Math.max(minX, Math.min(maxX, shape.x));
                shape.y = Math.max(minY, Math.min(maxY, shape.y));
                
                // Gambar persegi untuk shape
                const x = shape.x - shape.width / 2;
                const y = shape.y - shape.height / 2;
                
                ctx.beginPath();
                ctx.rect(x, y, shape.width, shape.height);
                
                // Warna shape berdasarkan tipe dan status blinking - UPDATED VERSION
                let baseColor = shape.color || '#2563eb';
                if (shape.blinking) {
                    // Berkedip dengan fade in/out dari transparan ke warna penuh
                    const now = Date.now();
                    const blinkCycle = (now % 1000) / 1000; // 1 detik cycle
                    const sinValue = Math.sin(blinkCycle * Math.PI * 4); // 4 kali per detik
                    
                    // Debug logging untuk shape yang blinking (hanya sesekali untuk menghindari spam)
                    if (index === 0 && Math.random() < 0.01) { // Log hanya untuk shape pertama dan jarang
                        console.log('ðŸ’¡ [DISPLAY] Blinking shape:', shape.code, 'sinValue:', sinValue.toFixed(2), 'cycle:', blinkCycle.toFixed(2));
                    }
                    
                    // Fade dari transparan (alpha 0) ke warna penuh (alpha 1)
                    const alpha = (sinValue + 1) / 2; // Convert -1 to 1 range ke 0 to 1
                    ctx.fillStyle = baseColor;
                    ctx.globalAlpha = alpha; // Fade effect dari transparan ke opaque
                } else {
                    // Shape tidak terlihat sama sekali saat tidak blinking
                    ctx.fillStyle = baseColor;
                    ctx.globalAlpha = 0; // Sepenuhnya transparan - tidak terlihat
                }
                
                ctx.fill();
                
                // Text label hanya untuk shape yang blinking
                if (shape.blinking) {
                    ctx.globalAlpha = 1;
                    ctx.font = 'bold 14px sans-serif';
                    
                    // Dynamic text color berdasarkan background untuk blinking
                    const now = Date.now();
                    const blinkCycle = (now % 1000) / 1000;
                    ctx.fillStyle = Math.sin(blinkCycle * Math.PI * 4) > 0 ? '#000000' : '#ffffff';
                    
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Hanya tampilkan tipe shape (NC, KM, CB) saat blinking
                    ctx.fillText(shape.type, shape.x, shape.y);
                }
                // Tidak ada text untuk shape yang tidak blinking
                
                ctx.restore();
            });
            
            // Request next frame untuk animasi jika ada shape yang blinking - DEBUG VERSION
            const blinkingShapesList = shapes.filter(shape => shape.blinking);
            const hasBlinkingShapes = blinkingShapesList.length > 0;
            
            if (hasBlinkingShapes) {
                if (!animationFrameId) {
                    console.log('ðŸŽ¬ [DISPLAY] Starting animation loop for', blinkingShapesList.length, 'blinking shapes:', blinkingShapesList.map(s => s.code));
                }
                animationFrameId = requestAnimationFrame(renderShapes);
            } else {
                if (animationFrameId) {
                    console.log('ðŸ›‘ [DISPLAY] Stopping animation loop - no blinking shapes');
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            }
        }

        // Helper function untuk brightness
        function getBrightness(color) {
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            return (r * 299 + g * 587 + b * 114) / 1000;
        }

        // Setup resize observer
        let resizeObserver;
        function setupResizeObserver() {
            if (window.ResizeObserver) {
                const img = document.getElementById('floorplan-img');
                if (img && !resizeObserver) {
                    resizeObserver = new ResizeObserver(entries => {
                        console.log('Image resized via ResizeObserver');
                        updateCanvasSize();
                    });
                    resizeObserver.observe(img);
                    console.log('ResizeObserver setup for display.html');
                }
            } else {
                // Fallback untuk browser lama
                console.log('ResizeObserver not supported in display.html');
                let lastImageSize = { width: 0, height: 0 };
                
                setInterval(() => {
                    const img = document.getElementById('floorplan-img');
                    if (img) {
                        const currentWidth = img.offsetWidth;
                        const currentHeight = img.offsetHeight;
                        
                        if (currentWidth !== lastImageSize.width || currentHeight !== lastImageSize.height) {
                            console.log('Image size changed via polling in display.html');
                            lastImageSize = { width: currentWidth, height: currentHeight };
                            updateCanvasSize();
                        }
                    }
                }, 500);
            }
        }

        // Listen for serial data untuk blinking shapes
        ipcRenderer.on('serial-data', (event, code) => {
            console.log('ðŸ“¡ [DISPLAY] Received serial data:', code);
            console.log('ðŸ“‹ [DISPLAY] Current shapes available:', shapes.length, shapes.map(s => s.code));
            console.log('ðŸ“Š [DISPLAY] Current activeAlerts:', activeAlerts.length, activeAlerts.map(a => ({ code: a.code, status: a.status })));
            
            // CRITICAL FIX: Process call dengan error handling untuk debug
            try {
                console.log('ðŸ“ž [DISPLAY] Calling processCall for code:', code);
                processCall(code);
                console.log('âœ… [DISPLAY] processCall completed for code:', code);
            } catch (error) {
                console.error('âŒ [DISPLAY] Error in processCall for code:', code, error);
            }
            
            // ADDITIONAL: Handle kode panggilan untuk shape blinking - DIRECT IMMEDIATE BLINKING
            if (code.startsWith('10')) {
                const targetShape = shapes.find(s => s.code === code);
                if (targetShape) {
                    console.log('ðŸ”„ [DISPLAY] Starting IMMEDIATE blink for shape:', targetShape.code, targetShape.type);
                    targetShape.blinking = true;
                    
                    // Tandai bahwa shape ini sedang blinking
                    blinkingShapes.set(code, true);
                    
                    // Simpan ke persistent blinking
                    persistentBlinking.set(code, true);
                    console.log('âœ… [DISPLAY] Added to persistent blinking:', code);
                    
                    // Start render loop untuk animasi yang smooth - IMMEDIATE
                    if (!animationFrameId) {
                        console.log('ðŸŽ¬ [DISPLAY] Starting IMMEDIATE animation loop');
                        renderShapes();
                    } else {
                        // Force render immediately even if animation is running
                        renderShapes();
                    }
                } else {
                    console.warn('âš ï¸ [DISPLAY] Shape not found for code:', code);
                    console.log('ðŸ” [DISPLAY] Available shapes:', shapes.map(s => ({ code: s.code, type: s.type })));
                    
                    // Try to load shapes if empty
                    if (shapes.length === 0) {
                        console.log('ðŸ”„ [DISPLAY] No shapes loaded, attempting to reload...');
                        loadDisplayConfig().then(() => {
                            // Retry after loading
                            const retryShape = shapes.find(s => s.code === code);
                            if (retryShape) {
                                console.log('ðŸ”„ [DISPLAY] Retry: Starting blink after reload for:', code);
                                retryShape.blinking = true;
                                blinkingShapes.set(code, true);
                                persistentBlinking.set(code, true);
                                renderShapes();
                            }
                        });
                    }
                }
            }
            
            // ADDITIONAL: Handle kode reset untuk shape blinking - DIRECT IMMEDIATE STOP
            if (code.startsWith('90')) {
                const targetCode = '10' + code.substring(2);
                console.log('ðŸ”„ [DISPLAY] Reset signal for IMMEDIATE shape blinking stop:', targetCode);
                
                // Stop blinking untuk shape yang sesuai - IMMEDIATE
                const targetShape = shapes.find(s => s.code === targetCode);
                if (targetShape) {
                    targetShape.blinking = false;
                    console.log('ðŸ›‘ [DISPLAY] Stopped IMMEDIATE blinking for shape:', targetShape.code, targetShape.type);
                } else {
                    console.warn('âš ï¸ [DISPLAY] Shape not found for reset:', targetCode);
                }
                
                // Remove dari tracking blinking shapes - IMMEDIATE
                if (blinkingShapes.has(targetCode)) {
                    blinkingShapes.delete(targetCode);
                    console.log('ðŸ—‘ï¸ [DISPLAY] Removed from blinkingShapes IMMEDIATELY:', targetCode);
                }
                
                // Remove dari persistent blinking - IMMEDIATE
                if (persistentBlinking.has(targetCode)) {
                    persistentBlinking.delete(targetCode);
                    console.log('ðŸ—‘ï¸ [DISPLAY] Removed from persistent blinking IMMEDIATELY:', targetCode);
                }
                
                // Render ulang untuk menampilkan perubahan - IMMEDIATE
                renderShapes();
            }
        });

        // Listen for call history updates untuk sinkronisasi dengan display_config.html dan index.html
        ipcRenderer.on('call-history-updated', (event, data) => {
            console.log('ðŸ”„ [DISPLAY] Received call history update from main:', {
                callHistoryCount: data.callHistory?.length || 0,
                activeAlertsCount: data.activeAlerts?.length || 0,
                persistentSoundsCount: data.persistentSounds?.length || 0,
                persistentBlinkingCount: data.persistentBlinking?.length || 0
            });
            
            // DEBUG: Log incoming active alerts statuses
            if (data.activeAlerts) {
                console.log('ðŸ” [DISPLAY] Incoming active alerts:', data.activeAlerts.map(a => ({ code: a.code, status: a.status })));
            }
            
            // Update call history and active alerts
            if (data.callHistory) {
                callHistory = data.callHistory;
                console.log('ðŸ“ [DISPLAY] Call history updated:', callHistory.length, 'entries');
            }
            
            if (data.activeAlerts) {
                const previousActiveAlerts = [...activeAlerts];
                activeAlerts = data.activeAlerts;
                console.log('âš ï¸ [DISPLAY] Active alerts updated:', activeAlerts.length, 'alerts');
                console.log('ðŸ“‹ [DISPLAY] Current active alerts statuses:', activeAlerts.map(a => ({ code: a.code, status: a.status })));
                
                // Handle popup notifications berdasarkan perubahan active alerts
                activeAlerts.forEach(alert => {
                    if (alert.status === 'active') {
                        const wasAlreadyActive = previousActiveAlerts.find(prev => prev.code === alert.code && prev.status === 'active');
                        if (!wasAlreadyActive) {
                            console.log('ðŸ”” [DISPLAY] New active alert detected:', alert.code, '- triggering blinking AND popup');
                            
                            // Show notification popup untuk alert baru
                            showNotificationPopup({
                                code: alert.code,
                                room: alert.room,
                                bed: alert.bed,
                                time: alert.time
                            });
                            
                            // Find and start blinking for the shape
                            const shape = shapes.find(s => s.code === alert.code);
                            if (shape) {
                                console.log('âœ… [DISPLAY] Found shape for code:', alert.code, '- starting blinking');
                                shape.blinking = true;
                                blinkingShapes.set(alert.code, true);
                                
                                // Add to persistent blinking
                                persistentBlinking.set(alert.code, true);
                                
                                // Start animation if not already running
                                if (!animationFrameId) {
                                    console.log('ðŸŽ¬ [DISPLAY] Starting animation loop for new blinking shape');
                                    renderShapes();
                                }
                            } else {
                                console.warn('âš ï¸ [DISPLAY] Shape not found for new alert code:', alert.code);
                                console.log('ðŸ” [DISPLAY] Available shapes:', shapes.map(s => ({ code: s.code, type: s.type })));
                            }
                        }
                    } else if (alert.status === 'completed') {
                        // Check if this was previously active (just completed)
                        const wasActive = previousActiveAlerts.find(prev => prev.code === alert.code && prev.status === 'active');
                        if (wasActive) {
                            console.log('âœ… [DISPLAY] Alert completed:', alert.code, '- triggering completed popup');
                            
                            // Show "Telah Ditangani" popup
                            resetNotification(alert.code);
                        }
                        
                        // Stop blinking for completed alerts
                        const shape = shapes.find(s => s.code === alert.code);
                        if (shape && shape.blinking) {
                            console.log('ðŸ›‘ [DISPLAY] Stopping blinking for completed alert:', alert.code);
                            shape.blinking = false;
                            blinkingShapes.delete(alert.code);
                            persistentBlinking.delete(alert.code);
                        }
                    }
                });
                
                // Update notification popups based on active alerts (fallback)
                updateNotificationPopups();
            }
            
            // Sync persistent sounds
            if (data.persistentSounds) {
                persistentSounds = new Map(data.persistentSounds);
                console.log('ðŸ”Š [DISPLAY] Persistent sounds updated:', persistentSounds.size, 'sounds');
            }
            
            // Sync blinking state ONLY for truly active persistent blinking (not completed)
            if (data.persistentBlinking) {
                const newPersistentBlinking = new Map(data.persistentBlinking);
                console.log('ðŸ”„ [DISPLAY] Syncing persistent blinking from main:', newPersistentBlinking.size, 'entries');
                
                // Apply blinking state berdasarkan persistent data AND alert status
                newPersistentBlinking.forEach((isActive, code) => {
                    const shape = shapes.find(s => s.code === code);
                    if (shape && isActive) {
                        // ONLY start blinking if there's actually an ACTIVE alert for this code
                        const hasActiveAlert = activeAlerts.some(alert => alert.code === code && alert.status === 'active');
                        
                        if (hasActiveAlert) {
                            shape.blinking = true;
                            blinkingShapes.set(code, true);
                            persistentBlinking.set(code, true);
                            console.log('ðŸ”„ [DISPLAY] Synced blinking for ACTIVE alert:', code);
                        } else {
                            console.log('ðŸš« [DISPLAY] Skipping blinking for completed/non-active alert:', code);
                            shape.blinking = false;
                            blinkingShapes.delete(code);
                            persistentBlinking.delete(code);
                        }
                    } else if (shape && !isActive) {
                        shape.blinking = false;
                        blinkingShapes.delete(code);
                        persistentBlinking.delete(code);
                        console.log('ðŸ›‘ [DISPLAY] Stopped blinking for inactive persistent code:', code);
                    }
                });
                
                // Start render loop jika ada blinking yang ACTIVE
                const hasActiveBlinking = Array.from(blinkingShapes.values()).some(isBlinking => isBlinking);
                if (hasActiveBlinking && !animationFrameId) {
                    console.log('ðŸŽ¬ [DISPLAY] Starting render loop for active blinking');
                    renderShapes();
                }
            }
        });

        // Spam click logic untuk exit
        let clickTimes = [];
        document.getElementById('logo-nurse-call').addEventListener('click', async function() {
                const now = Date.now();
            clickTimes = clickTimes.filter(t => now - t < 2000);
            clickTimes.push(now);
            if (clickTimes.length >= 5) {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                await ipcRenderer.invoke('back-to-main');
            }
        });

        // Window resize handler dengan debouncing dan scale adjustment (sama dengan display_config.html)
        
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                updateCanvasSize();
            }, 50); // Lebih responsif
        });
        
        // Handle orientation change untuk mobile
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                console.log('Orientation changed, updating canvas');
                updateCanvasSize();
            }, 100);
        });

        // Cleanup saat window ditutup - ENHANCED VERSION
        window.addEventListener('beforeunload', () => {
            console.log('Display window beforeunload - performing cleanup');
            performGlobalCleanup();
        });
        
        window.addEventListener('unload', () => {
            console.log('Display window unload - final cleanup');
            performGlobalCleanup();
        });
        
        // Also listen for page hide/show for better mobile support
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                console.log('Display page hidden - performing partial cleanup');
                // Don't do full cleanup, just pause non-critical operations
                activeTimeouts.forEach(timeoutId => {
                    if (timeoutId !== dateTimeInterval) {
                        clearTimeout(timeoutId);
                        activeTimeouts.delete(timeoutId);
                    }
                });
            }
        });

        // Update current time and date
        function updateDateTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { hour12: false });
            const dateStr = now.toLocaleDateString('en-GB');
            
            const timeEl = document.getElementById('current-time');
            const dateEl = document.getElementById('current-date');
            
            if (timeEl) timeEl.textContent = timeStr;
            if (dateEl) dateEl.textContent = dateStr;
        }

        // Use safe interval for datetime updates
        const dateTimeInterval = safeSetInterval(updateDateTime, 1000);
        updateDateTime();

        // Global audio element reference
        let globalAudioElement = null;
        let audioElementInitialized = false;

        // Function to ensure global audio element exists - FIXED MEMORY LEAK
        function ensureGlobalAudioElement() {
            if (!globalAudioElement || globalAudioElement.parentNode === null) {
                // CRITICAL FIX: Cleanup existing listeners before creating new element
                if (globalAudioElement && globalAudioElement.parentNode) {
                    // Remove all event listeners to prevent memory leaks
                    const newElement = globalAudioElement.cloneNode(false);
                    globalAudioElement.parentNode.replaceChild(newElement, globalAudioElement);
                    globalAudioElement = null;
                }

                // Remove any existing audio element dengan ID yang sama
                const existingAudio = document.getElementById('persistent-audio');
                if (existingAudio) {
                    // Clean up event listeners before removal
                    existingAudio.pause();
                    existingAudio.src = '';
                    existingAudio.load(); // Reset audio element
                    existingAudio.remove();
                }
                
                globalAudioElement = document.createElement('audio');
                globalAudioElement.id = 'persistent-audio';
                globalAudioElement.preload = 'auto';
                globalAudioElement.style.display = 'none'; // Hidden
                document.body.appendChild(globalAudioElement);
                console.log('Created global persistent audio element in display.html');
                
                // Set up permanent event listeners with proper cleanup handling
                const endedHandler = function() {
                    const code = this.dataset.currentCode;
                    const currentIndex = parseInt(this.dataset.currentIndex);
                    console.log('Global audio ended:', code, currentIndex);
                    if (code && !isNaN(currentIndex)) {
                        ipcRenderer.send('persistent-audio-ended', { code, currentIndex });
                    }
                };
                
                const errorHandler = function(error) {
                    const code = this.dataset.currentCode;
                    const currentIndex = parseInt(this.dataset.currentIndex);
                    console.error('Global audio error:', error);
                    if (code && !isNaN(currentIndex)) {
                        ipcRenderer.send('persistent-audio-ended', { code, currentIndex });
                    }
                };
                
                // Store handlers for cleanup later
                globalAudioElement._endedHandler = endedHandler;
                globalAudioElement._errorHandler = errorHandler;
                
                globalAudioElement.addEventListener('ended', endedHandler);
                globalAudioElement.addEventListener('error', errorHandler);
                
                globalAudioElement.addEventListener('loadstart', function() {
                    console.log('Audio loading started in display.html');
                });
                
                globalAudioElement.addEventListener('canplay', function() {
                    console.log('Audio can play in display.html');
                });
                
                // Notify main process that audio element is ready - only once
                if (!audioElementInitialized) {
                    audioElementInitialized = true;
                    console.log('Notifying main process that audio element is ready in display.html');
                    ipcRenderer.invoke('audio-element-ready');
                }
            }
            return globalAudioElement;
        }

        // ADDED: Cleanup function for audio element
        function cleanupGlobalAudioElement() {
            if (globalAudioElement) {
                globalAudioElement.pause();
                globalAudioElement.src = '';
                globalAudioElement.load();
                if (globalAudioElement._endedHandler) {
                    globalAudioElement.removeEventListener('ended', globalAudioElement._endedHandler);
                }
                if (globalAudioElement._errorHandler) {
                    globalAudioElement.removeEventListener('error', globalAudioElement._errorHandler);
                }
                if (globalAudioElement.parentNode) {
                    globalAudioElement.parentNode.removeChild(globalAudioElement);
                }
                globalAudioElement = null;
                audioElementInitialized = false;
            }
        }

        // Listen for persistent audio playback commands
        ipcRenderer.on('play-persistent-audio', (event, { code, soundFile, currentIndex, totalSounds }) => {
            console.log('ðŸ”Š [DISPLAY] Received persistent audio command:', { code, soundFile, currentIndex, totalSounds });
            
            // Ensure global audio element exists
            const audioElement = ensureGlobalAudioElement();
            
            // Store metadata FIRST before any audio operations
            audioElement.dataset.currentCode = code;
            audioElement.dataset.currentIndex = currentIndex.toString();
            
            // Set the audio source
            const newSrc = `sounds/${soundFile}`;
            
            // Only change source if different to avoid interruption
            if (!audioElement.src.includes(soundFile)) {
                audioElement.src = newSrc;
                console.log('ðŸŽµ [DISPLAY] Set audio source to:', audioElement.src);
            }
            
            // Play audio immediately if ready, otherwise wait for ready state
            const playAudio = () => {
                audioElement.play().then(() => {
                    console.log('ðŸŽµ [DISPLAY] Audio started successfully for code:', code, 'sound:', soundFile);
                }).catch(error => {
                    console.error('âŒ [DISPLAY] Failed to play audio:', error);
                    // Notify main process of failure
                    ipcRenderer.send('persistent-audio-ended', { code, currentIndex });
                });
            };
            
            if (audioElement.readyState >= 4) { // HAVE_ENOUGH_DATA
                playAudio();
            } else {
                audioElement.addEventListener('canplaythrough', playAudio, { once: true });
                audioElement.addEventListener('error', () => {
                    console.error('âŒ [DISPLAY] Audio load error for:', soundFile);
                    ipcRenderer.send('persistent-audio-ended', { code, currentIndex });
                }, { once: true });
            }
        });

        // Listen for stop persistent audio commands
        ipcRenderer.on('stop-persistent-audio', () => {
            console.log('ðŸ›‘ [DISPLAY] Received stop persistent audio command');
            if (globalAudioElement) {
                globalAudioElement.pause();
                globalAudioElement.currentTime = 0;
                globalAudioElement.dataset.currentCode = '';
                globalAudioElement.dataset.currentIndex = '';
                console.log('ðŸ›‘ [DISPLAY] Stopped global persistent audio');
            }
        });

        // Listen for persistent sound stopped events
        ipcRenderer.on('persistent-sound-stopped', (event, { code }) => {
            console.log('ðŸ›‘ [DISPLAY] Persistent sound stopped for code:', code);
            
            // Stop audio if it matches the code
            if (globalAudioElement && globalAudioElement.dataset.currentCode === code) {
                globalAudioElement.pause();
                globalAudioElement.currentTime = 0;
                globalAudioElement.dataset.currentCode = '';
                globalAudioElement.dataset.currentIndex = '';
                console.log('ðŸ›‘ [DISPLAY] Stopped audio for specific code:', code);
            }
            
            // Stop blinking for the corresponding shape
            const shape = shapes.find(s => s.code === code);
            if (shape && shape.blinking) {
                shape.blinking = false;
                blinkingShapes.delete(code);
                persistentBlinking.delete(code);
                console.log('ðŸ›‘ [DISPLAY] Stopped blinking for shape:', code);
                
                // Trigger render to show changes
                renderShapes();
            }
            
            // Remove from local persistent tracking
            if (persistentSounds.has(code)) {
                persistentSounds.delete(code);
                console.log('ðŸ—‘ï¸ [DISPLAY] Removed from persistent sounds:', code);
            }
        });

        // Check current audio status
        async function checkAudioStatus() {
            try {
                const status = await ipcRenderer.invoke('get-current-audio-status');
                if (status.isPlaying && status.currentSequence) {
                    console.log('Audio is currently playing, continuing with current sequence');
                    // Audio sudah playing di main process, tidak perlu melakukan apa-apa
                    // Audio element akan otomatis menerima command berikutnya
                }
            } catch (error) {
                console.error('Error checking audio status:', error);
            }
        }

        // Fallback function untuk play sounds in sequence (untuk kompatibilitas)
        function playSoundsInSequence(sounds, code = null) {
            let currentIndex = 0;
            
            function playNext() {
                // Cek apakah sound masih aktif di persistent (untuk avoid cancel)
                if (code && !persistentSounds.has(code)) {
                    console.log('Sound sequence cancelled for code:', code);
                    return;
                }
                
                if (currentIndex < sounds.length) {
                    const sound = new Audio();
                    const soundPath = `sounds/${sounds[currentIndex]}`;
                    sound.src = soundPath;
                    
                    sound.addEventListener('loadstart', () => console.log('Sound loading started:', soundPath));
                    sound.addEventListener('canplay', () => console.log('Sound can play:', soundPath));
                    sound.addEventListener('playing', () => console.log('Sound is playing:', soundPath));
                    sound.addEventListener('ended', () => console.log('Sound ended:', soundPath));
                    sound.addEventListener('error', (e) => console.error('Sound error:', e, soundPath));
                    
                    sound.oncanplaythrough = () => {
                        // Double check sebelum play
                        if (code && !persistentSounds.has(code)) {
                            console.log('Sound cancelled before play for code:', code);
                            return;
                        }
                        
                        console.log('Sound can play through:', soundPath);
                        sound.play().then(() => {
                            console.log('Sound started playing successfully:', soundPath);
                        }).catch(e => {
                            console.error('Error playing sound:', e, soundPath);
                            currentIndex++;
                            playNext();
                        });
                    };
                    
                    sound.onended = () => {
                        console.log('Sound finished playing:', soundPath);
                        currentIndex++;
                        playNext();
                    };
                    
                    sound.onerror = (e) => {
                        console.error('Error loading sound:', e, soundPath);
                        currentIndex++;
                        playNext();
                    };
                } else {
                    console.log('Finished playing all sounds for code:', code);
                    // Mark sound as finished but keep it persistent until reset
                    if (code && persistentSounds.has(code)) {
                        const soundData = persistentSounds.get(code);
                        soundData.isPlaying = false;
                        persistentSounds.set(code, soundData);
                        updatePersistentStateToMain();
                    }
                }
            }
            
            if (sounds.length > 0) {
                playNext();
            } else {
                console.log('No sounds to play');
            }
        }

        // Load display config saat startup
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                console.log('ðŸš€ [DISPLAY] Starting initialization...');
                
                // Step 1: Load master data first
                console.log('ðŸ“š [DISPLAY] Step 1: Loading master data...');
                await loadMasterData();
                
                // Step 2: Load display config  
                console.log('ðŸ—ï¸ [DISPLAY] Step 2: Loading display config...');
                await loadDisplayConfig();
                
                // Step 3: Load notification settings
                console.log('ðŸ”” [DISPLAY] Step 3: Loading notification settings...');
                await loadNotificationSettings();
                
                // Step 4: Set initial container position dengan fallback yang baik
                const container = document.getElementById('notification-popup-container');
                if (container) {
                    const initialPosition = notificationSettings.position || 'top-right';
                    setContainerPosition(container, initialPosition);
                    console.log('ðŸŽ¯ [DISPLAY] Initial container position set on startup to:', initialPosition);
                } else {
                    console.warn('âš ï¸ [DISPLAY] Notification container not found during startup');
                }
                
                // Step 5: Load active alerts and call history from main process
                console.log('ðŸ“Š [DISPLAY] Step 5: Loading active alerts from main...');
                await loadActiveAlertsFromMain();
                
                // Show notification about loaded history
                const historyLoadedCount = callHistory.length;
                if (historyLoadedCount > 0) {
                    console.log('ðŸ“Š [DISPLAY] Call history loaded at startup:', historyLoadedCount, 'entries');
                } else {
                    console.log('ðŸ†• [DISPLAY] Starting with empty call history');
                }
                
                // Step 6: Trigger blinking for any existing active alerts after shapes are loaded
                if (shapes.length > 0) {
                    console.log('ðŸ”„ [DISPLAY] Step 6: Shapes loaded, checking for active alerts...');
                    console.log('ðŸ“‹ [DISPLAY] Available shapes:', shapes.map(s => s.code));
                    console.log('âš ï¸ [DISPLAY] Active alerts to process:', activeAlerts.map(a => ({ code: a.code, status: a.status })));
                    
                    if (activeAlerts.length > 0) {
                        console.log('ðŸ”„ [DISPLAY] Triggering blinking for existing active alerts...');
                        triggerBlinkingForActiveAlerts();
                    }
                } else {
                    console.warn('âš ï¸ [DISPLAY] No shapes available after loading - serial data may not work properly');
                }
                
                // Step 7: Initialize global audio element
                console.log('ðŸ”Š [DISPLAY] Step 7: Initializing audio...');
                ensureGlobalAudioElement();
                
                // Step 8: Check if audio is currently playing and restore if needed
                await checkAudioStatus();
                
                // Step 9: Request restoration of any playing audio after navigation
                const restorationResult = await ipcRenderer.invoke('restore-audio-after-navigation');
                if (restorationResult.restored) {
                    console.log('ðŸ”Š [DISPLAY] Audio restoration completed:', restorationResult.status);
                }
                
                // Step 10: Setup datetime update - ALREADY SETUP ABOVE
                // updateDateTime();
                // setInterval(updateDateTime, 1000); // REMOVED - already setup with safeSetInterval
                
                console.log('âœ… [DISPLAY] Initialization completed successfully');
                console.log('ðŸ“Š [DISPLAY] Final state:', {
                    shapesCount: shapes.length,
                    masterDataCount: masterData.length,
                    activeAlertsCount: activeAlerts.length,
                    availableShapeCodes: shapes.map(s => s.code),
                    activeAlertCodes: activeAlerts.map(a => a.code)
                });
            } catch (error) {
                console.error('âŒ [DISPLAY] Error initializing display.html:', error);
            }
        });

        // Variables untuk master data dan sounds
        let masterData = [];
        let callHistory = [];
        let activeAlerts = [];
        let standbyMode = false; // Track standby mode state
        let lastStandbyNotification = null; // Track last standby notification time
        let persistentSounds = new Map();
        let persistentBlinking = new Map();

        // Notification and Sound Handling
        let notificationSettings = {
            displayFormat: "K{room}B{bed}",
            alertDuration: 30,
            soundEnabled: true,
            position: "top-right",
            animation: "slide-right",
            activeColor: "red",
            completedColor: "green",
            showDuration: 30,
            animationSpeed: 500
        };

        // Load master data
        async function loadMasterData() {
            try {
                console.log('ðŸ“š [DISPLAY] Loading master data...');
                const config = await ipcRenderer.invoke('load-config');
                masterData = config.masterData || [];
                console.log('ðŸ“š [DISPLAY] Master data loaded:', masterData.length, 'items');
                
                // Log detail master data untuk debugging
                masterData.forEach((item, index) => {
                    const sounds = [item.v1, item.v2, item.v3, item.v4, item.v5, item.v6].filter(v => v && v.trim() !== '');
                    console.log(`ðŸ“‹ [DISPLAY] Master data ${index + 1}:`, {
                        code: item.charCode,
                        room: item.roomName,
                        bed: item.bedName,
                        shape: item.shape,
                        soundCount: sounds.length,
                        sounds: sounds
                    });
                });
                
                // Jika tidak ada shapes di display config, coba buat dari master data
                if (shapes.length === 0 && masterData.length > 0) {
                    console.log('ðŸ”„ [DISPLAY] No shapes found, creating from master data...');
                    await createShapesFromMasterData();
                }
                
                return true;
            } catch (error) {
                console.error('âŒ [DISPLAY] Error loading master data:', error);
                return false;
            }
        }

        // Create shapes from master data
        async function createShapesFromMasterData() {
            try {
                const newShapes = [];
                masterData.forEach((item, index) => {
                    if (item.shape && item.shape.trim() !== '' && item.charCode) {
                        const newShape = {
                            code: item.charCode,
                            type: item.shape,
                            x: 100 + (index * 120), // Default positions
                            y: 100 + ((index % 3) * 100),
                            width: 90,
                            height: 70,
                            blinking: false,
                            color: getShapeColor(item.shape)
                        };
                        newShapes.push(newShape);
                        console.log(`âœ… [DISPLAY] Created shape from master data: ${item.charCode} (${item.shape})`);
                    }
                });
                
                if (newShapes.length > 0) {
                    shapes = newShapes;
                    console.log(`ðŸŽ¯ [DISPLAY] Created ${newShapes.length} shapes from master data`);
                    
                    // Log semua kode shape yang baru dibuat
                    const shapeCodes = shapes.map(s => s.code);
                    console.log('ðŸ” [DISPLAY] New shape codes available:', shapeCodes);
                    
                    // Render shapes
                    renderFloorplan();
                    return true;
                } else {
                    console.warn('âš ï¸ [DISPLAY] No valid shapes found in master data');
                    return false;
                }
            } catch (error) {
                console.error('âŒ [DISPLAY] Error creating shapes from master data:', error);
                return false;
            }
        }

        // Load notification settings
        async function loadNotificationSettings() {
            try {
                const config = await ipcRenderer.invoke('load-config');
                if (config.notificationSettings) {
                    console.log('ðŸ”§ [DISPLAY] Loading notification settings from config:', config.notificationSettings);
                    notificationSettings = { ...notificationSettings, ...config.notificationSettings };
                    console.log('ðŸ”§ [DISPLAY] Final notification settings:', notificationSettings);
                    
                    // Update container position immediately after loading settings
                    const container = document.getElementById('notification-popup-container');
                    if (container) {
                        setContainerPosition(container, notificationSettings.position);
                        console.log('ðŸŽ¯ [DISPLAY] Container position set after loading settings:', notificationSettings.position);
                    }
                } else {
                    console.log('ðŸ”§ [DISPLAY] No notification settings in config, using defaults:', notificationSettings);
                }
            } catch (error) {
                console.error('Error loading notification settings:', error);
            }
        }

        // Helper function to set container position
        function setContainerPosition(container, position) {
            if (!container) return;
            
            // Clear any existing position styles
            container.style.top = '';
            container.style.bottom = '';
            container.style.left = '';
            container.style.right = '';
            
            // Get window dimensions
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // CRITICAL FIX: Calculate better padding untuk visibility - lebih jauh dari edge  
            // ENHANCED padding untuk better visibility, especially for completed notifications
            const paddingX = Math.max(50, Math.round(windowWidth * 0.04)); // Increased to 4% with 50px minimum
            const paddingY = Math.max(30, Math.round(windowHeight * 0.03)); // Increased to 3% with 30px minimum
            
            // Apply position based on settings with improved padding
            switch (position) {
                case 'top-right':
                    container.style.top = `${paddingY}px`;
                    container.style.right = `${paddingX}px`;
                    break;
                case 'top-left':
                    container.style.top = `${paddingY}px`;
                    container.style.left = `${paddingX}px`;
                    break;
                case 'bottom-right':
                    container.style.bottom = `${paddingY}px`;
                    container.style.right = `${paddingX}px`;
                    break;
                case 'bottom-left':
                    container.style.bottom = `${paddingY}px`;
                    container.style.left = `${paddingX}px`;
                    break;
                default:
                    // Default to top-right if no valid position dengan improved padding
                    container.style.top = `${paddingY}px`;
                    container.style.right = `${paddingX}px`;
            }
            
            console.log('ðŸŽ¯ [DISPLAY] Container positioned at:', position, 'with padding:', { x: paddingX, y: paddingY });
        }
        
        // Load active alerts from main process
        async function loadActiveAlertsFromMain() {
            try {
                const data = await ipcRenderer.invoke('get-call-history');
                if (data) {
                    callHistory = data.callHistory || [];
                    activeAlerts = data.activeAlerts || [];
                    
                    console.log('ðŸ”„ [DISPLAY] Loaded from main process:', {
                        callHistoryCount: callHistory.length,
                        activeAlertsCount: activeAlerts.length
                    });
                    
                    // DEBUG: Log status of all alerts loaded
                    if (activeAlerts.length > 0) {
                        console.log('ðŸ“‹ [DISPLAY] Alert statuses on load:');
                        activeAlerts.forEach(alert => {
                            console.log(`  - ${alert.code}: ${alert.status}`);
                        });
                    }
                    
                    // Update persistent data
                    if (data.persistentSounds) {
                        persistentSounds = new Map(data.persistentSounds);
                        console.log('ðŸ”Š [DISPLAY] Loaded persistent sounds:', persistentSounds.size);
                    }
                    
                    if (data.persistentBlinking) {
                        const loadedPersistentBlinking = new Map(data.persistentBlinking);
                        console.log('ðŸ”„ [DISPLAY] Loaded persistent blinking from main:', loadedPersistentBlinking.size);
                        
                        // Apply blinking to shapes - ONLY FOR ACTIVE ALERTS
                        console.log('ðŸ”„ [DISPLAY] Applying persistent blinking to shapes (ACTIVE ONLY)...');
                        loadedPersistentBlinking.forEach((isActive, code) => {
                            if (isActive) {
                                // CRITICAL: Only apply blinking if there's an ACTIVE alert
                                const activeAlert = activeAlerts.find(alert => alert.code === code && alert.status === 'active');
                                
                                if (activeAlert) {
                                    const shape = shapes.find(s => s.code === code);
                                    if (shape) {
                                        console.log('âœ… [DISPLAY] Applied blinking to shape for ACTIVE alert:', code);
                                        shape.blinking = true;
                                        blinkingShapes.set(code, true);
                                        persistentBlinking.set(code, true);
                                    } else {
                                        console.warn('âš ï¸ [DISPLAY] Shape not found for persistent blinking code:', code);
                                    }
                                } else {
                                    console.log('ðŸš« [DISPLAY] Skipping blinking for completed/non-active persistent code:', code);
                                }
                            }
                        });
                        
                        // Start render loop if needed (only if there are actually active blinking shapes)
                        const activeBlinkingCount = Array.from(blinkingShapes.values()).filter(Boolean).length;
                        if (activeBlinkingCount > 0 && !animationFrameId) {
                            console.log('ðŸŽ¬ [DISPLAY] Starting render loop for', activeBlinkingCount, 'active blinking shapes');
                            renderShapes();
                        }
                    }
                    
                    // Update notification popups untuk active alerts yang sudah ada
                    updateNotificationPopups();
                }
            } catch (error) {
                console.error('Error loading active alerts from main process:', error);
            }
        }

        // Notification Functions
        function showNotificationPopup(data) {
            console.log('ðŸŽ¯ [DISPLAY] showNotificationPopup called with data:', {
                code: data.code,
                room: data.room,
                bed: data.bed,
                time: data.time
            });
            
            const container = document.getElementById('notification-popup-container');
            if (!container) {
                console.error('Notification container not found');
                return;
            }

            // Check if notification already exists for this code
            const existingPopup = document.querySelector(`[data-code="${data.code}"]`);
            if (existingPopup) {
                console.log('âš ï¸ [DISPLAY] Popup already exists for code:', data.code, 'keeping existing popup');
                return;
            }

            // Load notification settings
            const settings = notificationSettings || {
                position: 'top-right',
                animation: 'slide-right',
                activeColor: 'red',
                completedColor: 'green',
                showDuration: 30,
                animationSpeed: 500
            };

            // CRITICAL FIX: Update container position using current notification settings (hanya jika belum di-set)
            const currentPosition = container.style.top || container.style.bottom;
            if (!currentPosition) {
                // Only set position if not already positioned
                setContainerPosition(container, notificationSettings.position || settings.position);
                console.log('ðŸŽ¯ [DISPLAY] Initial container position set for popup');
            } else {
                console.log('ðŸŽ¯ [DISPLAY] Container already positioned, maintaining current position');
            }

            // Create popup with active color
            const popup = document.createElement('div');
            popup.className = `notification-popup bg-${settings.activeColor}-50 border-l-4 border-${settings.activeColor}-500 p-4 rounded-lg shadow-lg mb-3`;
            popup.setAttribute('data-code', data.code);
            
            // Clean and format room and bed names
            const cleanRoom = data.room.replace(/^(R\.|Ruangan|Room)\s*/i, '').trim();
            const cleanBed = data.bed.replace(/^(Bed|B\.)\s*/i, '').trim();
            
            // Create content with active color and animation
            popup.innerHTML = `
                <div class="flex justify-between items-start">
                    <div class="flex-1">
                        <div class="flex items-center">
                            <h3 class="font-bold text-lg text-${settings.activeColor}-800">Nurse Call</h3>
                            <span class="ml-2 px-2 py-0.5 bg-${settings.activeColor}-100 text-${settings.activeColor}-800 text-xs font-medium rounded-full">ACTIVE</span>
                        </div>
                        <p class="text-sm text-${settings.activeColor}-600 mt-1 font-medium">${cleanRoom}</p>
                        <p class="text-xs text-${settings.activeColor}-600 mt-0.5">${cleanBed}</p>
                    </div>
                    <div class="flex flex-col items-end">
                        <span class="text-xs text-white px-2 py-1 rounded bg-${settings.activeColor}-500">${data.time}</span>
                        <span class="text-xs text-${settings.activeColor}-500 mt-1">Kode: ${data.code}</span>
                    </div>
                </div>
                <div class="mt-3 flex items-center justify-between">
                    <div class="flex items-center">
                        <span class="w-2 h-2 bg-${settings.activeColor}-500 rounded-full alert-pulse"></span>
                        <span class="ml-2 text-xs text-${settings.activeColor}-600 font-medium">Menunggu Response</span>
                    </div>
                    <button class="text-xs text-white px-3 py-1.5 rounded-full bg-${settings.activeColor}-500 hover:bg-${settings.activeColor}-600 transition-colors">
                        <i class="fas fa-bell"></i> Active
                    </button>
                </div>
            `;

            // Add animation class based on settings
            const animationClass = {
                'slide-right': 'animate-slide-right',
                'slide-left': 'animate-slide-left',
                'fade': 'animate-fade',
                'bounce': 'animate-bounce'
            }[settings.animation] || 'animate-slide-right';

            popup.style.animationDuration = `${settings.animationSpeed}ms`;
            popup.classList.add(animationClass);

            // Add to container
            container.appendChild(popup);

            // Auto-hide popup panggilan setelah 3 detik
            setTimeout(() => {
                popup.classList.add('hide');
                setTimeout(() => {
                    if (popup.parentNode) {
                        popup.parentNode.removeChild(popup);
                        activeNotifications.delete(data.code);
                        console.log('ðŸ—‘ï¸ [DISPLAY] Call notification popup auto-removed after 3 seconds for code:', data.code);
                    }
                }, settings.animationSpeed);
            }, 3000); // Fixed 3 seconds for call popup

            // Store reference for reset handling
            activeNotifications.set(data.code, popup);
        }

        // Function to handle reset notification with applied settings
        function resetNotification(code) {
            const popup = activeNotifications.get(code);
            if (popup) {
                console.log('ðŸ”„ [DISPLAY] Updating notification popup to "completed" for reset code:', code);
                
                // Load notification settings
                const settings = notificationSettings || {
                    position: 'top-right',
                    animation: 'slide-right',
                    activeColor: 'red',
                    completedColor: 'green',
                    showDuration: 30,
                    animationSpeed: 500
                };
                
                // CRITICAL FIX: Reposition container to ensure better visibility for completed popup
                const container = document.getElementById('notification-popup-container');
                if (container) {
                    // Use enhanced positioning specifically for completed notifications
                    const windowWidth = window.innerWidth;
                    const windowHeight = window.innerHeight;
                    
                    // ENHANCED padding for completed notifications - move further left for better visibility
                    const paddingX = Math.max(80, Math.round(windowWidth * 0.06)); // Increased to 6% with 80px minimum
                    const paddingY = Math.max(40, Math.round(windowHeight * 0.04)); // Increased to 4% with 40px minimum
                    
                    // Clear existing position
                    container.style.top = '';
                    container.style.bottom = '';
                    container.style.left = '';
                    container.style.right = '';
                    
                    // Apply enhanced position for better visibility
                    switch (notificationSettings.position || settings.position) {
                        case 'top-right':
                            container.style.top = `${paddingY}px`;
                            container.style.right = `${paddingX}px`;
                            break;
                        case 'top-left':
                            container.style.top = `${paddingY}px`;
                            container.style.left = `${paddingX}px`;
                            break;
                        case 'bottom-right':
                            container.style.bottom = `${paddingY}px`;
                            container.style.right = `${paddingX}px`;
                            break;
                        case 'bottom-left':
                            container.style.bottom = `${paddingY}px`;
                            container.style.left = `${paddingX}px`;
                            break;
                        default:
                            container.style.top = `${paddingY}px`;
                            container.style.right = `${paddingX}px`;
                    }
                    
                    console.log('ðŸŽ¯ [DISPLAY] Enhanced container position for completed popup:', {
                        position: notificationSettings.position || settings.position,
                        padding: { x: paddingX, y: paddingY }
                    });
                }

                // Update status to completed with completed color and static appearance (no animation)
                popup.className = `notification-popup bg-${settings.completedColor}-50 border-l-4 border-${settings.completedColor}-500 p-4 rounded-lg shadow-xl mb-3`;
                popup.style.opacity = '1';
                popup.style.transform = 'translateX(0)';
                popup.style.zIndex = '10000';
                popup.style.animation = 'none'; // Remove any blinking animations
                
                // Get data for display - try from active alert first, then master data
                let data = activeAlerts.find(alert => alert.code === code);
                let cleanRoom, cleanBed;
                
                if (data) {
                    // Use data from active alert (already cleaned)
                    cleanRoom = data.room;
                    cleanBed = data.bed;
                } else {
                    // Fallback to master data
                    const masterItem = masterData.find(d => d.charCode === code);
                    cleanRoom = masterItem ? masterItem.roomName.replace(/^(R\.|Ruangan|Room)\s*/i, '').trim() : 'Unknown';
                    cleanBed = masterItem ? masterItem.bedName.replace(/^(Bed|B\.)\s*/i, '').trim() : 'Unknown';
                }
                const now = new Date();
                const currentTime = now.toLocaleTimeString('en-US', { hour12: false });
                
                // Update content with completed color and static visibility (no blinking)
                popup.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div class="flex-1">
                            <div class="flex items-center">
                                <h3 class="font-bold text-lg text-${settings.completedColor}-800">Telah Ditangani</h3>
                                <span class="ml-2 px-2 py-0.5 bg-${settings.completedColor}-100 text-${settings.completedColor}-800 text-xs font-medium rounded-full">COMPLETED</span>
                            </div>
                            <p class="text-sm text-${settings.completedColor}-600 mt-1 font-medium">${cleanRoom}</p>
                            <p class="text-xs text-${settings.completedColor}-600 mt-0.5">${cleanBed}</p>
                        </div>
                        <div class="flex flex-col items-end">
                            <span class="text-xs text-white px-2 py-1 rounded bg-${settings.completedColor}-500">${currentTime}</span>
                            <span class="text-xs text-${settings.completedColor}-500 mt-1">Nurse Call</span>
                        </div>
                    </div>
                    <div class="mt-3 flex items-center justify-between">
                        <div class="flex items-center">
                            <span class="w-2 h-2 bg-${settings.completedColor}-500 rounded-full opacity-100"></span>
                            <span class="ml-2 text-xs text-${settings.completedColor}-600 font-medium">Telah di Respon</span>
                        </div>
                        <button class="text-xs text-white px-3 py-1.5 rounded-full bg-${settings.completedColor}-500 transition-colors">
                            <i class="fas fa-check"></i> Selesai
                        </button>
                    </div>
                `;

                // Remove popup "Telah Ditangani" setelah 3 detik
                setTimeout(() => {
                    popup.classList.add('hide');
                    setTimeout(() => {
                        if (popup.parentNode) {
                            popup.parentNode.removeChild(popup);
                            activeNotifications.delete(code);
                            console.log('ðŸ—‘ï¸ [DISPLAY] Completed notification popup removed after 3 seconds for code:', code);
                        }
                    }, settings.animationSpeed);
                }, 3000); // Fixed 3 seconds for completed popup
            }
        }

        // Map to track active notifications
        const activeNotifications = new Map();
        
        // Function to update notification popups berdasarkan active alerts (fallback only)
        function updateNotificationPopups() {
            console.log('ðŸ”„ [DISPLAY] Fallback popup update check, active alerts:', activeAlerts.length);
            
            // CRITICAL FIX: Ensure container position is set correctly with fallback
            const container = document.getElementById('notification-popup-container');
            if (container) {
                // Prioritaskan notificationSettings.position dengan fallback yang tepat
                const targetPosition = notificationSettings.position || 'top-right';
                setContainerPosition(container, targetPosition);
                console.log('ðŸŽ¯ [DISPLAY] Container position updated in updateNotificationPopups:', targetPosition);
            }
            
            // Remove popups untuk alerts yang sudah tidak ada (cleanup only)
            const activeCodes = new Set(activeAlerts.map(a => a.code));
            activeNotifications.forEach((popup, code) => {
                if (!activeCodes.has(code)) {
                    console.log('ðŸ—‘ï¸ [DISPLAY] Removing orphaned popup for:', code);
                    if (popup.parentNode) {
                        popup.parentNode.removeChild(popup);
                    }
                    activeNotifications.delete(code);
                }
            });
            
            console.log('ðŸ“Š [DISPLAY] Popup cleanup completed. Active popups:', activeNotifications.size);
        }

        // Function untuk set standby indicator
        function setStandbyIndicator(color) {
            const standbyIndicator = document.getElementById('standby-indicator');
            if (!standbyIndicator) return;
            
            standbyIndicator.classList.remove('bg-red-500', 'bg-green-500', 'bg-yellow-500', 'bg-gray-500', 'bg-blue-500');
            
            if (color === 'red') {
                standbyIndicator.classList.add('bg-red-500');
            } else if (color === 'green') {
                standbyIndicator.classList.add('bg-green-500');
            } else if (color === 'yellow') {
                standbyIndicator.classList.add('bg-yellow-500');
            } else if (color === 'gray') {
                standbyIndicator.classList.add('bg-gray-500');
            } else if (color === 'blue') {
                standbyIndicator.classList.add('bg-blue-500');
            }
        }

        // Update connection status
        function updateConnectionStatus() {
            if (standbyMode) {
                setStandbyIndicator('yellow');
            } else {
                setStandbyIndicator('gray');
            }
        }

        // Check if master data is valid
        function isValidMasterData(data) {
            if (!data) return false;
            
            // Cek apakah data memiliki nilai yang dibutuhkan
            if (!data.roomName || data.roomName.trim() === '') return false;
            if (!data.bedName || data.bedName.trim() === '') return false;
            
            // Cek minimal satu file suara harus ada
            const hasSound = [data.v1, data.v2, data.v3, data.v4, data.v5, data.v6].some(v => v && v.trim() !== '');
            if (!hasSound) return false;
            
            return true;
        }

        // Update persistent state to main - RESTORED: Display.html can create calls but with sync
        async function updatePersistentStateToMain() {
            try {
                const dataToSend = {
                    callHistory: callHistory, // Send call history untuk sinkronisasi
                    activeAlerts: activeAlerts, // Send active alerts untuk sinkronisasi
                    persistentSounds: Array.from(persistentSounds.entries()),
                    persistentBlinking: Array.from(persistentBlinking.entries())
                };
                
                console.log('ðŸ“¤ [DISPLAY] Sending state to main process:', {
                    callHistoryCount: dataToSend.callHistory.length,
                    activeAlertsCount: dataToSend.activeAlerts.length,
                    activeAlertsStatuses: dataToSend.activeAlerts.map(a => ({ code: a.code, status: a.status })),
                    persistentSoundsCount: dataToSend.persistentSounds.length,
                    persistentBlinkingCount: dataToSend.persistentBlinking.length
                });
                
                await ipcRenderer.invoke('update-call-history', dataToSend);
                console.log('ðŸ“¤ [DISPLAY] Persistent state updated to main process');
            } catch (error) {
                console.error('âŒ [DISPLAY] Error updating persistent state to main process:', error);
            }
        }

        // Alias function untuk compatibility
        async function updateCallHistoryToMain() {
            return await updatePersistentStateToMain();
        }

        // Process call function - main logic for handling all codes
        async function processCall(code) {
            console.log('ðŸš€ [DISPLAY] Processing call with code:', code);
            
            // Khusus untuk kode standby
            if (code === '99' || code === '99:') {
                const wasInStandby = standbyMode;
                
                // Set standby mode dan indikator
                standbyMode = true;
                setStandbyIndicator('green');
                setTimeout(() => {
                    setStandbyIndicator('yellow');
                }, 500);
                
                // Hanya update indikator tanpa notifikasi
                console.log('Entered standby mode - indicator updated');
                return;
            }

            // Khusus untuk kode 100 (keluar dari standby)
            if (code === '100') {
                const wasInStandby = standbyMode;
                standbyMode = false;
                updateConnectionStatus();
                
                // Hanya update indikator tanpa notifikasi
                console.log('Exited standby mode - indicator updated');
                
                // Reset standby notification state
                lastStandbyNotification = null;
                return;
            }
            
            // Untuk kode reset (90x atau 90xx)
            if (code.startsWith('90')) {
                console.log('ðŸ›‘ [DISPLAY] RESET CODE DETECTED! Processing reset for:', code);
                const bedNumber = code.substring(2);
                const originalCode = `10${bedNumber}`;
                
                console.log('ðŸ”„ [DISPLAY] Reset code detected:', code, 'â†’ Original code:', originalCode);
                console.log('ðŸ” [DISPLAY] Current active alerts before reset:', activeAlerts.length);
                
                // Cari data di master data untuk validasi
                console.log('ðŸ” [DISPLAY] Looking for master data for originalCode:', originalCode);
                console.log('ðŸ” [DISPLAY] Master data count:', masterData.length);
                const data = masterData.find(d => d.charCode === originalCode);
                console.log('ðŸ” [DISPLAY] Found master data:', !!data, data ? 'valid' : 'not found');
                
                if (!isValidMasterData(data)) {
                    console.log('âŒ [DISPLAY] Original code not found or incomplete in master data:', originalCode);
                    console.log('ðŸ” [DISPLAY] Available master data codes:', masterData.map(d => d.charCode));
                    return;
                }
                
                console.log('âœ… [DISPLAY] Master data validation passed for:', originalCode);

                // STOP AUDIO IMMEDIATELY
                console.log('Stopping persistent sound for code:', originalCode);
                await ipcRenderer.invoke('stop-persistent-sounds', { code: originalCode });

                // STOP BLINKING IMMEDIATELY
                const targetShape = shapes.find(s => s.code === originalCode);
                if (targetShape) {
                    targetShape.blinking = false;
                    blinkingShapes.delete(originalCode);
                    persistentBlinking.delete(originalCode);
                    console.log('Stopped blinking for shape:', originalCode);
                    renderShapes();
                }
                
                // Update call history untuk reset
                const alertIndex = activeAlerts.findIndex(alert => alert.code === originalCode);
                if (alertIndex !== -1) {
                    const now = new Date();
                    const resetTimeStr = formatDateTime(now);
                    
                    // Update call history
                    const historyIndex = callHistory.findIndex(call => call.code === originalCode && call.status === 'active');
                    if (historyIndex !== -1) {
                        callHistory[historyIndex].status = 'completed';
                        callHistory[historyIndex].resetTime = now;
                        callHistory[historyIndex].resetTimeStr = resetTimeStr;
                    }
                    
                    // Update active alert dan simpan reference untuk notifikasi
                    const alertDisplayText = activeAlerts[alertIndex].display;
                    activeAlerts[alertIndex].status = 'completed';
                    activeAlerts[alertIndex].resetTime = now;
                    activeAlerts[alertIndex].resetTimeStr = resetTimeStr;
                    
                    // SEGERA kirim update ke main process untuk sinkronisasi real-time
                    await updateCallHistoryToMain();
                    
                                    // Tampilkan notifikasi OS untuk reset - ENHANCED FORMAT
                showEnhancedOSNotification(originalCode, 'reset');
                
                // NOTE: Popup "Telah Ditangani" akan ditampilkan oleh active alerts sync, bukan di sini
                    
                    // Hapus dari active alerts setelah configured duration
                    const completedRemoveDelay = (notificationSettings.showDuration || 30) * 1000;
                    setTimeout(async () => {
                        const idx = activeAlerts.findIndex(a => a.id === activeAlerts[alertIndex].id);
                        if (idx !== -1) {
                            activeAlerts.splice(idx, 1);
                            // Update main process lagi setelah hapus dari active alerts
                            await updateCallHistoryToMain();
                        }
                    }, completedRemoveDelay); // Use configured duration instead of hardcoded 3000
                    
                    console.log(`ðŸ”„ [DISPLAY] Reset alert ${originalCode} marked as completed and will be removed in ${completedRemoveDelay/1000} seconds`);
                    console.log(`ðŸ“Š [DISPLAY] Broadcasting update - Active alerts: ${activeAlerts.length}, Call history: ${callHistory.length}`);
                }
                
                // Remove dari persistent tracking
                if (persistentSounds.has(originalCode)) {
                    persistentSounds.delete(originalCode);
                    console.log('ðŸ—‘ï¸ [DISPLAY] Removed from persistent sounds:', originalCode);
                }
                
                // Update ke main process
                updatePersistentStateToMain();
                
                return;
            }
            
            // Untuk kode panggilan normal (10x atau 10xx)
            if (code.startsWith('10')) {
                console.log('Processing call code:', code);
                
                // Cek apakah kode ada di master data dan memiliki data lengkap
                const data = masterData.find(d => d.charCode === code);
                if (!isValidMasterData(data)) {
                    console.log('Call code not found or incomplete in master data:', code);
                    return;
                }
                
                // Cek apakah panggilan sudah aktif
                const existingAlert = activeAlerts.find(alert => alert.code === code && alert.status === 'active');
                if (existingAlert) {
                    console.log('Call already active:', code);
                    return;
                }

                // TAMBAHAN: Cek apakah panggilan ini sudah pernah ditangani sebelumnya
                const recentlyHandled = callHistory.find(call => 
                    call.code === code && 
                    call.status === 'completed' && 
                    call.resetTime && 
                    (Date.now() - new Date(call.resetTime).getTime() < 5000) // 5 detik threshold
                );

                if (recentlyHandled) {
                    console.log('ðŸš« [DISPLAY] Call was recently handled, ignoring:', code);
                    console.log('â±ï¸ [DISPLAY] Time since reset:', Math.round((Date.now() - new Date(recentlyHandled.resetTime).getTime()) / 1000), 'seconds ago');
                    return;
                }
                
                // Kedip biru sekali
                setStandbyIndicator('blue');
                setTimeout(() => {
                    if (standbyMode) {
                        setStandbyIndicator('yellow');
                    } else {
                        updateConnectionStatus();
                    }
                }, 500);

                // Proses panggilan dan catat ke call history
                const now = new Date();
                const timeStr = formatDateTime(now);
                
                // Clean room and bed names - remove prefixes
                const cleanRoom = data.roomName.replace(/^(R\.|Ruangan|Room)\s*/i, '').trim();
                const cleanBed = data.bedName.replace(/^(Bed|B\.)\s*/i, '').trim();
                const displayText = `${cleanRoom} - ${cleanBed}`;
                
                // Buat entry call history baru dengan format yang lebih sederhana
                const callEntry = {
                    id: Date.now(),
                    code: code,
                    room: cleanRoom,
                    bed: cleanBed,
                    display: displayText,
                    time: timeStr,
                    timestamp: now,
                    status: 'active',
                    resetTime: null,
                    resetTimeStr: ''
                };
                
                // Tambah ke call history dan active alerts
                callHistory.unshift(callEntry);
                activeAlerts.push({...callEntry});
                
                // Kirim update call history ke main process untuk dibagikan dengan index.html
                updateCallHistoryToMain();
                
                // Tampilkan notifikasi OS untuk alert baru - ENHANCED FORMAT
                showEnhancedOSNotification(code, 'call');
                
                // NOTE: Popup notification akan ditampilkan oleh active alerts sync, bukan di sini
                
                // Play sounds dan simpan ke persistent
                const sounds = [];
                if (data.v1) sounds.push(data.v1);
                if (data.v2) sounds.push(data.v2);
                if (data.v3) sounds.push(data.v3);
                if (data.v4) sounds.push(data.v4);
                if (data.v5) sounds.push(data.v5);
                if (data.v6) sounds.push(data.v6);
                
                if (sounds.length > 0) {
                    // Gunakan global audio player di main process
                    console.log('Requesting persistent sound playback for code:', code);
                    ipcRenderer.invoke('play-persistent-sounds', { code, sounds }).then(result => {
                        if (result.success) {
                            console.log('Persistent sound playback started for code:', code);
                        } else {
                            console.error('Failed to start persistent sound playback:', result.error);
                        }
                    });
                }
            }
        }

        // Format date time function
        function formatDateTime(date) {
            const timeStr = date.toLocaleTimeString('en-US', { hour12: false });
            return `${timeStr}.${date.getDate()}-${date.getMonth() + 1}-${date.getFullYear()}`;
        }
        
        // Function untuk show notification
        function showNotification(type, message, duration = 5000) {
            const container = document.getElementById('notification-popup-container');
            if (!container) {
                console.error('Notification container not found');
                return;
            }

            // Remove existing notification with same code if it exists
            const existingNotifications = container.querySelectorAll('.notification-popup');
            existingNotifications.forEach(notification => {
                if (notification.dataset.code === message) {
                    notification.remove();
                }
            });

            const notification = document.createElement('div');
            notification.className = 'notification-popup';
            notification.dataset.code = message;

            if (type === 'call') {
                notification.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="font-bold text-lg text-red-800">Nurse Call</h3>
                            <p class="text-sm text-red-600">${message}</p>
                        </div>
                        <span class="text-xs text-white px-2 py-1 rounded bg-red-500">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="mt-3 flex items-center">
                        <span class="w-2 h-2 bg-red-500 rounded-full animate-pulse"></span>
                        <span class="ml-2 text-xs text-red-600">Menunggu Response</span>
                    </div>
                `;
                notification.classList.add('show');
            } else if (type === 'reset') {
                notification.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="font-bold text-lg text-green-800">Telah Ditangani</h3>
                            <p class="text-sm text-green-600">${message}</p>
                        </div>
                        <span class="text-xs text-white px-2 py-1 rounded bg-green-500">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="mt-3 flex items-center">
                        <span class="w-2 h-2 bg-green-500 rounded-full"></span>
                        <span class="ml-2 text-xs text-green-600">Telah di Respon</span>
                    </div>
                `;
                notification.classList.add('completed');
                duration = 3000; // Fixed 3 seconds for reset notifications
            } else {
                // System notifications (warning, error, etc)
                const bgColor = {
                    success: 'bg-green-500',
                    error: 'bg-red-500',
                    warning: 'bg-yellow-500',
                    info: 'bg-blue-500'
                }[type] || 'bg-gray-500';

                notification.innerHTML = `
                    <div class="flex items-center">
                        <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'} mr-2"></i>
                        <span>${message}</span>
                    </div>
                `;
                notification.classList.add(bgColor, 'text-white', 'px-4', 'py-2', 'rounded', 'shadow-lg');
            }

            container.appendChild(notification);

            setTimeout(() => {
                notification.classList.add('hide');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, notificationSettings.animationSpeed || 500);
            }, duration);

            return notification;
        }

        // Tambahkan fungsi untuk mengirim notifikasi sistem dengan format lengkap
        async function showOSNotification(title, body, urgency = 'normal') {
            try {
                await ipcRenderer.invoke('show-system-notification', { title, body, urgency });
            } catch (error) {
                console.error('Error showing system notification:', error);
            }
        }

        // Fungsi helper untuk membuat OS notification dengan format lengkap
        async function showEnhancedOSNotification(code, type = 'call') {
            try {
                const data = masterData.find(d => d.charCode === code);
                if (!data) {
                    console.warn('No master data found for OS notification code:', code);
                    return;
                }

                // Clean and format room and bed names
                const cleanRoom = data.roomName.replace(/^(R\.|Ruangan|Room)\s*/i, '').trim();
                const cleanBed = data.bedName.replace(/^(Bed|B\.)\s*/i, '').trim();
                
                // Get shape type from master data or default to NC
                const shapeType = data.shape || 'NC';
                
                // Format title selalu sama
                const title = 'Nurse Call Response System';
                
                // Format body: ShapeType - Room - Bed
                const bodyLine1 = `${shapeType} - ${cleanRoom} - ${cleanBed}`;
                // Format status line berdasarkan tipe
                const bodyLine2 = type === 'call' ? 'Menunggu Response' : 'Telah Di Tangani';
                
                // Gabungkan body dengan line break
                const body = `${bodyLine1}\n${bodyLine2}`;
                
                // Set urgency berdasarkan tipe
                const urgency = type === 'call' ? 'critical' : 'normal';
                
                console.log('ðŸ“¢ [DISPLAY] Sending enhanced OS notification:', { title, body, urgency });
                await ipcRenderer.invoke('show-system-notification', { title, body, urgency });
            } catch (error) {
                console.error('Error showing enhanced system notification:', error);
            }
        }

        // Initialize notification container if not exists
        document.addEventListener('DOMContentLoaded', () => {
            if (!document.getElementById('notification-popup-container')) {
                const container = document.createElement('div');
                container.id = 'notification-popup-container';
                document.body.appendChild(container);
            }

            if (!document.getElementById('sound-container')) {
                const soundContainer = document.createElement('div');
                soundContainer.id = 'sound-container';
                document.body.appendChild(soundContainer);
            }
        });

        // Listen for notification settings updates
        ipcRenderer.on('notification-settings-updated', async (event, newSettings) => {
            console.log('ðŸ”” [DISPLAY] Received notification settings update:', newSettings);
            
            // Update local notification settings
            notificationSettings = { ...notificationSettings, ...newSettings };
            
            // CRITICAL FIX: Update container position immediately dengan error handling
            const container = document.getElementById('notification-popup-container');
            if (container) {
                const newPosition = notificationSettings.position || 'top-right';
                setContainerPosition(container, newPosition);
                console.log('ðŸŽ¯ [DISPLAY] Container position updated after settings change to:', newPosition);
                
                // Force reposition any existing popups
                const existingPopups = container.querySelectorAll('.notification-popup');
                if (existingPopups.length > 0) {
                    console.log('ðŸ”„ [DISPLAY] Repositioning', existingPopups.length, 'existing popups');
                }
            } else {
                console.warn('âš ï¸ [DISPLAY] Notification container not found during settings update');
            }
            
            // Also reload from config to ensure consistency
            await loadNotificationSettings();
        });

        // Test functions untuk debugging (opsional)
        window.testDisplayCall = {
            test101: () => {
                console.log('ðŸ§ª [TEST] Testing call 101...');
                processCall('101');
            },
            test901: () => {
                console.log('ðŸ§ª [TEST] Testing reset 901...');
                processCall('901');
            },
            test99: () => {
                console.log('ðŸ§ª [TEST] Testing standby 99...');
                processCall('99');
            },
            test100: () => {
                console.log('ðŸ§ª [TEST] Testing exit standby 100...');
                processCall('100');
            },
            testCustom: (code) => {
                console.log('ðŸ§ª [TEST] Testing custom code:', code);
                processCall(code.toString());
            },
            showMasterData: () => {
                console.log('ðŸ“‹ [TEST] Current master data:', masterData);
                return masterData;
            },
            showShapes: () => {
                console.log('ðŸ” [TEST] Current shapes:', shapes);
                return shapes;
            },
            testMasterDataLookup: (code) => {
                const data = masterData.find(d => d.charCode === code);
                console.log('ðŸ” [TEST] Lookup result for code', code, ':', data);
                return data;
            },
            testShapeBlinking: (code) => {
                console.log('ðŸ§ª [TEST] Testing shape blinking for code:', code);
                const shape = shapes.find(s => s.code === code);
                if (shape) {
                    console.log('ðŸ§ª [TEST] Found shape:', shape);
                    shape.blinking = true;
                    blinkingShapes.set(code, true);
                    if (!animationFrameId) {
                        renderShapes();
                    }
                    console.log('ðŸ§ª [TEST] Started blinking for shape:', code);
                } else {
                    console.warn('ðŸ§ª [TEST] Shape not found with code:', code);
                    console.log('ðŸ§ª [TEST] Available shapes:', shapes.map(s => s.code));
                }
            },
            stopShapeBlinking: (code) => {
                console.log('ðŸ§ª [TEST] Stopping shape blinking for code:', code);
                const shape = shapes.find(s => s.code === code);
                if (shape) {
                    shape.blinking = false;
                    blinkingShapes.delete(code);
                    renderShapes();
                }
            },
            forceRender: () => {
                console.log('ðŸ§ª [TEST] Force rendering shapes...');
                renderShapes();
            },
            debugState: () => {
                console.log('ðŸ§ª [DEBUG] Current state:');
                console.log('- shapes:', shapes.length, shapes.map(s => ({ code: s.code, type: s.type, blinking: s.blinking })));
                console.log('- masterData:', masterData.length, 'entries');
                console.log('- activeAlerts:', activeAlerts.length, activeAlerts.map(a => ({ code: a.code, status: a.status })));
                console.log('- blinkingShapes:', Array.from(blinkingShapes.entries()));
                console.log('- animationFrameId:', animationFrameId);
                return {
                    shapes: shapes,
                    masterData: masterData,
                    activeAlerts: activeAlerts,
                    blinkingShapes: Array.from(blinkingShapes.entries()),
                    animationRunning: !!animationFrameId
                };
            },
            reloadAll: async () => {
                console.log('ðŸ”„ [TEST] Reloading all data...');
                await loadMasterData();
                await loadDisplayConfig();
                await loadActiveAlertsFromMain();
                console.log('âœ… [TEST] Reload completed');
            },
            simulateSerial: (code) => {
                console.log('ðŸ“¡ [TEST] Simulating serial data:', code);
                // Trigger the same event that would come from serial
                const event = new CustomEvent('serial-data');
                ipcRenderer.emit('serial-data', event, code);
            }
        };

        console.log('ðŸ§ª [DISPLAY] Test functions loaded. Use window.testDisplayCall for testing.');
        console.log('Available test functions: test101(), test901(), testShapeBlinking(code), debugState(), reloadAll(), simulateSerial(code)');

        // Helper function untuk trigger blinking pada shape berdasarkan active alerts
        function triggerBlinkingForActiveAlerts() {
            console.log('ðŸ”„ [DISPLAY] Triggering blinking ONLY for ACTIVE alerts...');
            console.log('ðŸ“‹ [DISPLAY] Current shapes available:', shapes.length, shapes.map(s => s.code));
            console.log('âš ï¸ [DISPLAY] All alerts:', activeAlerts.length, activeAlerts.map(a => ({ code: a.code, status: a.status })));
            
            // Filter HANYA alert yang benar-benar ACTIVE (bukan completed)
            const trulyActiveAlerts = activeAlerts.filter(alert => alert.status === 'active');
            console.log(`ðŸ” [DISPLAY] Found ${trulyActiveAlerts.length} truly ACTIVE alerts out of ${activeAlerts.length} total alerts`);
            
            // Log status all alerts for debugging
            activeAlerts.forEach(alert => {
                console.log(`ðŸ“‹ [DISPLAY] Alert ${alert.code}: status=${alert.status}`);
            });
            
            let triggeredCount = 0;
            trulyActiveAlerts.forEach(alert => {
                const shape = shapes.find(s => s.code === alert.code);
                if (shape) {
                    console.log('âœ… [DISPLAY] Starting blinking for ACTIVE alert:', alert.code, 'status:', alert.status);
                    shape.blinking = true;
                    blinkingShapes.set(alert.code, true);
                    persistentBlinking.set(alert.code, true);
                    triggeredCount++;
                } else {
                    console.warn('âš ï¸ [DISPLAY] Shape not found for active alert:', alert.code);
                    console.log('ðŸ” [DISPLAY] Available shape codes:', shapes.map(s => s.code));
                    console.log('ðŸ” [DISPLAY] Available shapes detail:', shapes.map(s => ({ code: s.code, type: s.type })));
                }
            });
            
            // Start animation if there are blinking shapes
            const hasBlinkingShapes = Array.from(blinkingShapes.values()).some(isBlinking => isBlinking);
            if (hasBlinkingShapes && !animationFrameId) {
                console.log('ðŸŽ¬ [DISPLAY] Starting animation loop for', triggeredCount, 'active blinking shapes');
                renderShapes();
            } else if (trulyActiveAlerts.length === 0) {
                console.log('ðŸ”‡ [DISPLAY] No active alerts found - no blinking to start');
            } else {
                console.log('ðŸŽ¬ [DISPLAY] Animation already running or no valid shapes found');
            }
            
            console.log('ðŸŽ¯ [DISPLAY] Blinking trigger summary:', {
                totalAlerts: activeAlerts.length,
                activeAlerts: trulyActiveAlerts.length,
                shapesTriggered: triggeredCount,
                animationRunning: !!animationFrameId
            });
        }
    </script>
</body>
</html> 